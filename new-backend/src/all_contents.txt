Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\all_contents.txt:


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\script.ps1:
# Get the current directory
$currentDir = Get-Location

# Define the output text file
$outputFile = Join-Path -Path $currentDir -ChildPath "all_contents.txt"

# Clear the content of the output file if it exists
if (Test-Path $outputFile) {
    Clear-Content -Path $outputFile
}

# Get all files in the current directory and subdirectories
Get-ChildItem -Path $currentDir -Recurse -File | ForEach-Object {
    # Write the file name to the output file
    Add-Content -Path $outputFile -Value "Contents of $($_.FullName):"

    # Write the content of the file to the output file
    Get-Content -Path $_.FullName | Add-Content -Path $outputFile

    # Add a separator for readability
    Add-Content -Path $outputFile -Value "`r`n"  # Adds a new line
}

Write-Host "All contents have been copied to $outputFile"


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\server.ts:
// src/server.ts
import express from 'express';
import cors from 'cors';
import 'dotenv/config';
import "reflect-metadata";
import { container } from "tsyringe";
import { UserController } from "./controllers/UserController";
import { AlbumController } from "./controllers/AlbumController";
import { DatabaseService } from "./services/DatabaseService";
import { UserService } from "./services/UserService";
import { AlbumService } from "./services/AlbumService";

// Auto-registration
container.registerSingleton(DatabaseService);
container.register(UserService, {useClass: UserService});
container.register(AlbumService, {useClass: AlbumService});

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Routes
app.get('/api/users', async (req, res) => {
    try {
        const userController = container.resolve(UserController);
        const users = await userController.getAllUsers();
        res.json(users);
    } catch (error) {
        console.error('Error fetching users:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.get('/api/albums', async (req, res) => {
    try {
        const albumController = container.resolve(AlbumController);
        const albums = await albumController.getAllAlbums();
        res.json(albums);
    } catch (error) {
        console.error('Error fetching albums:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
    console.log('Shutting down gracefully...');
    const dbService = container.resolve(DatabaseService);
    await dbService.close();
    process.exit(0);
});


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\types.ts:
// src/types.ts
import { InferSelectModel } from 'drizzle-orm';
import { usersTable, albumsTable, usersToAlbumsTable } from './db/schema';

export type User = InferSelectModel<typeof usersTable>;
export type CreateUser = Omit<User, 'user_id'>;

export type Album = InferSelectModel<typeof albumsTable>;
export type CreateAlbum = Omit<Album, 'album_id'>;

export type UserAlbumAssignment = InferSelectModel<typeof usersToAlbumsTable>;


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\controllers\AlbumController.ts:
// src/controllers/AlbumController.ts
import { injectable, inject } from "tsyringe";
import { AlbumService } from "../services/AlbumService";
import { Album, CreateAlbum, UserAlbumAssignment } from "../types";

@injectable()
export class AlbumController {
  constructor(@inject(AlbumService) private albumService: AlbumService) {}

  async createAlbum(data: CreateAlbum): Promise<Album> {
    return await this.albumService.create(data);
  }

  async getAllAlbums(): Promise<Album[]> {
    return await this.albumService.getAll();
  }

  async getAlbumById(id: number): Promise<Album | null> {
    return await this.albumService.getById(id);
  }

  async updateAlbum(id: number, data: Partial<Album>): Promise<Album> {
    return await this.albumService.update(id, data);
  }

  async deleteAlbum(id: number): Promise<void> {
    await this.albumService.delete(id);
  }

  async assignAlbums(assignments: UserAlbumAssignment[]): Promise<void> {
    await this.albumService.assignAlbums(assignments);
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\controllers\AuthController.ts:
import { injectable } from 'tsyringe';
import { Request, Response } from 'express';
import { UserService } from '../services/UserService';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

@injectable()
export class AuthController {
  constructor(private userService: UserService) {}

  async signup(req: Request, res: Response) {
    try {
      const { username, password, email } = req.body;
      const existingUser = await this.userService.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ error: 'User already exists' });
      }
      const hashedPassword = await bcrypt.hash(password, 10);
      const newUser = await this.userService.createUser({username, password: hashedPassword, email});
      const token = this.generateToken(newUser);
      res.status(201).json({ message: 'User created', token });
    } catch (error) {
      console.error('Error during signup:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async login(req: Request, res: Response) {
    try {
      const { username, password } = req.body;
      const user = await this.userService.getUserByUsername(username);
      if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }
      const token = this.generateToken(user);
      res.status(200).json({ token });
    } catch (error) {
      console.error('Error during login:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  private generateToken(user: { user_id: number; username: string }) {
    return jwt.sign(
      { id: user.user_id, username: user.username },
      process.env.JWT_SECRET || 'supersecretkey',
      { expiresIn: '1h' }
    );
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\controllers\UserController.ts:
// src/controllers/UserController.ts
import { injectable, inject } from "tsyringe";
import { UserService } from "../services/UserService";
import { User, CreateUser } from "../types";

@injectable()
export class UserController {
  constructor(@inject(UserService) private userService: UserService) {}

  async createUser(data: CreateUser): Promise<User> {
    return await this.userService.create(data);
  }

  async getAllUsers(): Promise<User[]> {
    return await this.userService.getAll();
  }

  async getUserById(id: number): Promise<User | null> {
    return await this.userService.getById(id);
  }

  async updateUser(id: number, data: Partial<User>): Promise<User> {
    return await this.userService.update(id, data);
  }

  async deleteUser(id: number): Promise<void> {
    await this.userService.delete(id);
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\db\schema.ts:
// src/db/schema.ts
import { integer, pgTable, primaryKey, varchar } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

// Users table
export const usersTable = pgTable("users", {
  user_id: integer().primaryKey().generatedAlwaysAsIdentity(),
  username: varchar({ length: 255 }).notNull(),
  password: varchar({ length: 255 }).notNull(),
  email: varchar({ length: 255 }).notNull().unique(),
});

// Albums table
export const albumsTable = pgTable("albums", {
  album_id: integer().primaryKey().generatedAlwaysAsIdentity(),
  album_name: varchar({ length: 255 }).notNull(),
  artist_name: varchar({ length: 255 }).notNull(),
});

// Junction table to represent the many-to-many relationship between users and albums
export const usersToAlbumsTable = pgTable(
  "users_to_albums",
  {
    user_id: integer("user_id")
      .notNull()
      .references(() => usersTable.user_id),
    album_id: integer("album_id")
      .notNull()
      .references(() => albumsTable.album_id),
  },
  (t) => ({
    pk: primaryKey(t.user_id, t.album_id), // Composite primary key
  })
);

// Relations for users
export const usersRelations = relations(usersTable, ({ many }) => ({
  usersToAlbums: many(usersToAlbumsTable),
}));

// Relations for albums
export const albumsRelations = relations(albumsTable, ({ many }) => ({
  usersToAlbums: many(usersToAlbumsTable),
}));

// Relations for usersToAlbums junction table
export const usersToAlbumsRelations = relations(usersToAlbumsTable, ({ one }) => ({
  user: one(usersTable, {
    fields: [usersToAlbumsTable.user_id],
    references: [usersTable.user_id],
  }),
  album: one(albumsTable, {
    fields: [usersToAlbumsTable.album_id],
    references: [albumsTable.album_id],
  }),
}));


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\db\seed_example.ts:
// src/db/index.ts
import 'dotenv/config';
import "reflect-metadata"
import { container } from "tsyringe";
import { UserController } from "../controllers/UserController";
import { AlbumController } from "../controllers/AlbumController";
import { DatabaseService } from "../services/DatabaseService";
import { UserService } from "../services/UserService";
import { AlbumService } from "../services/AlbumService";
import { CreateUser, CreateAlbum, UserAlbumAssignment } from "../types";

// Register services
container.registerSingleton(DatabaseService);
container.register(UserService, {useClass: UserService});
container.register(AlbumService, {useClass: AlbumService});

async function seedDatabase() {
    const userController = container.resolve(UserController);
    const albumController = container.resolve(AlbumController);

    console.log('--- User Operations ---');
    const usersToCreate: CreateUser[] = [
        { username: 'JohnDoe', password: 'password1', email: 'john@example.com' },
        { username: 'JaneDoe', password: 'password2', email: 'jane@example.com' },
        { username: 'Alice', password: 'password3', email: 'alice@example.com' }
    ];
    const createdUsers = await Promise.all(usersToCreate.map(user => userController.createUser(user)));
    console.log('Inserted users:', createdUsers);

    console.log('--- Album Operations ---');
    const albumsToCreate: CreateAlbum[] = [
        { album_name: 'Abbey Road', artist_name: 'The Beatles' },
        { album_name: 'Sticky Fingers', artist_name: 'The Rolling Stones' },
        { album_name: 'L.A. Woman', artist_name: 'The Doors' },
        { album_name: 'Led Zeppelin IV', artist_name: 'Led Zeppelin' },
        { album_name: 'Paranoid', artist_name: 'Black Sabbath' },
    ];
    const createdAlbums = await Promise.all(albumsToCreate.map(album => albumController.createAlbum(album)));
    console.log('Inserted albums:', createdAlbums);

    return { createdUsers, createdAlbums };
}

async function assignAlbums(userController: UserController, albumController: AlbumController, createdUsers: any[], createdAlbums: any[]) {
    const johnDoe = createdUsers.find(u => u.username === 'JohnDoe')!;
    const johnsAlbums: UserAlbumAssignment[] = [
        { user_id: johnDoe.user_id, album_id: createdAlbums[0].album_id },
        { user_id: johnDoe.user_id, album_id: createdAlbums[1].album_id }
    ];
    await albumController.assignAlbums(johnsAlbums);
    console.log('JohnDoe associated with multiple albums.');

    const sharedAlbum = createdAlbums.find(a => a.album_name === 'L.A. Woman')!;
    const sharedAlbumAssignments: UserAlbumAssignment[] = [
        { user_id: johnDoe.user_id, album_id: sharedAlbum.album_id },
        { user_id: createdUsers.find(u => u.username === 'JaneDoe')!.user_id, album_id: sharedAlbum.album_id }
    ];
    await albumController.assignAlbums(sharedAlbumAssignments);
    console.log('L.A. Woman assigned to multiple users.');
}

async function performQueries(userController: UserController, albumController: AlbumController, createdUsers: any[], createdAlbums: any[]) {
    console.log('All users:', await userController.getAllUsers());
    console.log('All albums:', await albumController.getAllAlbums());

    const janeDoe = createdUsers.find(u => u.username === 'JaneDoe');
    if (janeDoe) {
        console.log('JaneDoe details:', await userController.getUserById(janeDoe.user_id));
    }

    const stickyFingers = createdAlbums.find(a => a.album_name === 'Sticky Fingers');
    if (stickyFingers) {
        console.log('Sticky Fingers details:', await albumController.getAlbumById(stickyFingers.album_id));
    }

    const alice = createdUsers.find(u => u.username === 'Alice');
    if (alice) {
        console.log('Updated user Alice:', await userController.updateUser(alice.user_id, { email: 'newalice@example.com' }));
    }

    const abbeyRoad = createdAlbums.find(a => a.album_name === 'Abbey Road');
    if (abbeyRoad) {
        console.log('Updated album Abbey Road:', await albumController.updateAlbum(abbeyRoad.album_id, { artist_name: 'The Beatles' }));
    }
}

async function main() {
    const dbService = container.resolve(DatabaseService);
    
    try {
        const { createdUsers, createdAlbums } = await seedDatabase();
        const userController = container.resolve(UserController);
        const albumController = container.resolve(AlbumController);

        await assignAlbums(userController, albumController, createdUsers, createdAlbums);
        await performQueries(userController, albumController, createdUsers, createdAlbums);

    } catch (error) {
        console.error('Error running the script:', error);
    } finally {
        await dbService.close();
    }
}

main().catch(console.error);


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\interfaces\IEntityService.ts:
// src/interfaces/IEntityService.ts
export interface IEntityService<T, C> {
  create(data: C): Promise<T>;
  getAll(): Promise<T[]>;
  getById(id: number): Promise<T | null>;
  update(id: number, data: Partial<T>): Promise<T>;
  delete(id: number): Promise<void>;
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\middleware\AuthMiddleware.ts:
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export class AuthMiddleware {
  static authenticateJWT(req: Request, res: Response, next: NextFunction): void {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      res.status(401).json({ error: 'Token not provided' });
      return; // Ensure it returns void
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'supersecretkey');
      (req as any).user = decoded; // Attach the decoded user information to the request object
      next(); // Call next middleware
    } catch (error) {
      res.status(403).json({ error: 'Invalid or expired token' });
    }
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\services\AlbumService.ts:
// src/services/AlbumService.ts
import { injectable, inject } from "tsyringe";
import { IEntityService } from "../interfaces/IEntityService";
import { Album, CreateAlbum, UserAlbumAssignment } from "../types";
import { albumsTable, usersToAlbumsTable } from "../db/schema";
import { eq } from "drizzle-orm";
import { DatabaseService } from "./DatabaseService";

@injectable()
export class AlbumService implements IEntityService<Album, CreateAlbum> {
  constructor(@inject(DatabaseService) private dbService: DatabaseService) {}

  async create(data: CreateAlbum): Promise<Album> {
    const [insertedAlbum] = await this.dbService.getDb().insert(albumsTable).values(data).returning();
    return insertedAlbum;
  }

  async getAll(): Promise<Album[]> {
    return await this.dbService.getDb().select().from(albumsTable);
  }

  async getById(id: number): Promise<Album | null> {
    const [album] = await this.dbService.getDb().select().from(albumsTable).where(eq(albumsTable.album_id, id));
    return album ?? null;
  }

  async update(id: number, data: Partial<Album>): Promise<Album> {
    const [updatedAlbum] = await this.dbService.getDb().update(albumsTable).set(data).where(eq(albumsTable.album_id, id)).returning();
    return updatedAlbum;
  }

  async delete(id: number): Promise<void> {
    await this.dbService.getDb().delete(albumsTable).where(eq(albumsTable.album_id, id));
  }

  async assignAlbums(assignments: UserAlbumAssignment[]): Promise<void> {
    await this.dbService.getDb().insert(usersToAlbumsTable).values(assignments);
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\services\DatabaseService.ts:
// src/services/DatabaseService.ts
import { injectable, singleton } from "tsyringe";
import { drizzle } from 'drizzle-orm/postgres-js';
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from '../db/schema';

@singleton()
@injectable()
export class DatabaseService {
  private db: PostgresJsDatabase<typeof schema>;
  private client: postgres.Sql;

  constructor() {
    if (!process.env.DATABASE_URL) {
      throw new Error('DATABASE_URL is not set in the environment variables');
    }

    console.log('Initializing database connection...');

    this.client = postgres(process.env.DATABASE_URL, { 
      prepare: false,
    });

    this.db = drizzle(this.client, { schema });

    console.log('Database connection initialized');
  }

  getDb() {
    return this.db;
  }

  async close() {
    if (this.client) {
      await this.client.end();
      console.log('Database connection closed');
    }
  }
}


Contents of C:\Users\nick1\Javascript\pern-music\new-backend\src\services\UserService.ts:
import { injectable, inject } from "tsyringe";
import { IEntityService } from "../interfaces/IEntityService";
import { User, CreateUser } from "../types";
import { usersTable } from "../db/schema";
import { eq } from "drizzle-orm";
import { DatabaseService } from "./DatabaseService";
import bcrypt from 'bcryptjs';

@injectable()
export class UserService implements IEntityService<User, CreateUser> {
  constructor(@inject(DatabaseService) private dbService: DatabaseService) {}

  async create(data: CreateUser): Promise<User> {
    const hashedPassword = await bcrypt.hash(data.password, 10);
    const [insertedUser] = await this.dbService.getDb().insert(usersTable).values({
      ...data,
      password: hashedPassword
    }).returning();
    return insertedUser;
  }

  async getAll(): Promise<User[]> {
    return await this.dbService.getDb().select().from(usersTable);
  }

  async getById(id: number): Promise<User | null> {
    const [user] = await this.dbService.getDb().select().from(usersTable).where(eq(usersTable.user_id, id));
    return user ?? null;
  }

  async update(id: number, data: Partial<User>): Promise<User> {
    if (data.password) {
      data.password = await bcrypt.hash(data.password, 10);
    }
    const [updatedUser] = await this.dbService.getDb().update(usersTable).set(data).where(eq(usersTable.user_id, id)).returning();
    return updatedUser;
  }

  async delete(id: number): Promise<void> {
    await this.dbService.getDb().delete(usersTable).where(eq(usersTable.user_id, id));
  }

  async getUserByUsername(username: string): Promise<User | null> {
    const [user] = await this.dbService.getDb().select().from(usersTable).where(eq(usersTable.username, username));
    return user ?? null;
  }

  async createUser(data: CreateUser): Promise<User> {
    return this.create(data);
  }

  async validateUser(username: string, password: string): Promise<User | null> {
    const user = await this.getUserByUsername(username);
    if (user && await bcrypt.compare(password, user.password)) {
      return user;
    }
    return null;
  }
}


